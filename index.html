<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Î¶¨ÏπòÎßàÏûë Ìå® ÏÉùÏÑ±Í∏∞</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        --bg-color: #f0f2f5;
        --panel-color: #ffffff;
        --primary-color: #333333;
        --accent-color: #5d6d7e;
        --save-btn-color: #27ae60;
      }

      body {
        font-family: "Noto Sans KR", sans-serif;
        background-color: var(--bg-color);
        margin: 0;
        padding: 40px 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      h1 {
        margin-bottom: 30px;
        color: var(--primary-color);
        font-weight: 700;
      }

      .container {
        background: var(--panel-color);
        padding: 30px;
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        width: 100%;
        max-width: 900px;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 20px;
        margin-bottom: 25px;
      }

      .input-group {
        display: flex;
        flex-direction: column;
      }

      .input-group label {
        font-size: 13px;
        font-weight: 700;
        color: #666666;
        margin-bottom: 8px;
      }

      .select-row {
        display: flex;
        gap: 5px;
      }

      input,
      select {
        padding: 10px;
        border: 1px solid #dddddd;
        border-radius: 6px;
        font-family: inherit;
        font-size: 15px;
        background: #fafafa;
      }

      input:focus,
      select:focus {
        outline: 0;
        border-color: var(--accent-color);
        background: #ffffff;
      }

      .full-width {
        grid-column: 1 / -1;
      }

      .btn-area {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }

      button {
        padding: 14px 40px;
        border: 0;
        border-radius: 8px;
        font-weight: 700;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.2s;
        background-color: var(--save-btn-color);
        color: #ffffff;
        box-shadow: 0 4px 6px rgba(39, 174, 96, 0.2);
      }

      button:hover {
        background-color: #219150;
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0);
      }

      .canvas-wrapper {
        margin-top: 40px;
        display: flex;
        justify-content: center;
        background: transparent;
      }

      canvas {
        max-width: 100%;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      }
    </style>
  </head>
  <body>
    <h1>üÄÑ nanikiru-gen</h1>

    <div class="container">
      <div class="controls">
        <div class="input-group">
          <label>Íµ≠ (Round)</label>
          <div class="select-row">
            <select id="wind">
              <option value="Îèô">Îèô (East)</option>
              <option value="ÎÇ®">ÎÇ® (South)</option>
              <option value="ÏÑú">ÏÑú (West)</option>
              <option value="Î∂Å">Î∂Å (North)</option>
            </select>
            <select id="round">
              <option value="1">1Íµ≠</option>
              <option value="2">2Íµ≠</option>
              <option value="3">3Íµ≠</option>
              <option value="4">4Íµ≠</option>
            </select>
          </div>
        </div>
        <div class="input-group">
          <label>Ïàú (Turn)</label>
          <input type="number" id="turn" value="4" min="0" max="20" />
        </div>
        <div class="input-group">
          <label>ÏûêÎ¶¨ (Seat)</label>
          <select id="seat">
            <option value="ÎèôÍ∞Ä">ÎèôÍ∞Ä</option>
            <option value="ÎÇ®Í∞Ä">ÎÇ®Í∞Ä</option>
            <option value="ÏÑúÍ∞Ä" selected>ÏÑúÍ∞Ä</option>
            <option value="Î∂ÅÍ∞Ä">Î∂ÅÍ∞Ä</option>
          </select>
        </div>
        <div class="input-group">
          <label>ÎèÑÎùº (Dora)</label>
          <input type="text" id="dora" value="6s" />
        </div>
      </div>

      <div class="controls">
        <div class="input-group full-width">
          <label>ÏÜêÌå® (Hand)</label>
          <input type="text" id="hand" value="11566m123p445s34z" />
        </div>
        <div class="input-group full-width">
          <label>ÌõÑÎ°ú (Naki)</label>
          <input type="text" id="naki" placeholder="Ïòà: 111z" value="" />
        </div>
      </div>

      <div class="btn-area">
        <button onclick="downloadImage()">
          Ïù¥ÎØ∏ÏßÄ Îã§Ïö¥Î°úÎìú (ÏïàÎêòÎ©¥ ÏïÑÎûò Ïù¥ÎØ∏ÏßÄ Ïö∞ÌÅ¥Î¶≠ÌõÑ Ï†ÄÏû•)
        </button>
      </div>
    </div>

    <div class="canvas-wrapper">
      <canvas id="canvas" width="1000" height="250"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const context = canvas.getContext("2d");
      const elements = {
        wind: document.getElementById("wind"),
        round: document.getElementById("round"),
        turn: document.getElementById("turn"),
        seat: document.getElementById("seat"),
        dora: document.getElementById("dora"),
        hand: document.getElementById("hand"),
        naki: document.getElementById("naki"),
      };
      const assetPath = "./img/";

      const tileWidth = 66;
      const tileHeight = 90;
      const radius = 8;

      const doraScale = 0.65;
      const doraWidth = tileWidth * doraScale;
      const doraHeight = tileHeight * doraScale;

      const imageCache = {};

      window.addEventListener("load", draw);

      document.querySelectorAll("input").forEach((input) => {
        input.addEventListener("input", draw);
      });
      document.querySelectorAll("select").forEach((select) => {
        select.addEventListener("change", draw);
      });

      function parseTiles(text) {
        if (!text) {
          return [];
        }
        const result = [];
        const regex = /([0-9]+)([mpsz])/g;
        let match;
        while ((match = regex.exec(text)) !== null) {
          const numbers = match[1];
          const suit = match[2];
          for (const number of numbers) {
            result.push(number + suit);
          }
        }
        return result;
      }

      function loadImage(code) {
        return new Promise((resolve) => {
          if (imageCache[code]) {
            resolve(imageCache[code]);
            return;
          }
          const image = new Image();
          image.src = `${assetPath}${code}.png`;
          image.onload = () => {
            imageCache[code] = image;
            resolve(image);
          };
          image.onerror = () => resolve(null);
        });
      }

      function roundRect(x, y, width, height, cornerRadius) {
        let r = cornerRadius;
        if (width < 2 * r) {
          r = width / 2;
        }
        if (height < 2 * r) {
          r = height / 2;
        }
        context.beginPath();
        context.moveTo(x + r, y);
        context.arcTo(x + width, y, x + width, y + height, r);
        context.arcTo(x + width, y + height, x, y + height, r);
        context.arcTo(x, y + height, x, y, r);
        context.arcTo(x, y, x + width, y, r);
        context.closePath();
        return context;
      }

      async function draw() {
        const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(1, "#e6e6e6");
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);

        const wind = elements.wind.value;
        const round = elements.round.value;
        const turn = elements.turn.value;
        const seat = elements.seat.value;
        const infoText = `${wind}${round}Íµ≠ ${turn}Ïàú ${seat}  ÎèÑÎùº`;

        const doraCode = parseTiles(elements.dora.value)[0] || null;
        const handTiles = parseTiles(elements.hand.value);
        const nakiText = elements.naki.value.trim();
        const nakiSets = nakiText ? nakiText.split(/\s+/) : [];
        const nakiTileSets = nakiSets.map(parseTiles);

        context.font = '500 26px "Noto Sans KR"';
        const textWidth = context.measureText(infoText).width;

        const topGap = 10;
        const topBlockWidth = textWidth + (doraCode ? topGap + doraWidth : 0);

        let topStartX = (canvas.width - topBlockWidth) / 2;
        const topY = 60;

        context.fillStyle = "#333333";
        context.textBaseline = "middle";
        context.textAlign = "left";
        context.fillText(infoText, topStartX, topY);

        if (doraCode) {
          const doraImage = await loadImage(doraCode);
          const doraX = topStartX + textWidth + topGap;
          const doraY = topY - doraHeight / 2;

          context.save();
          context.shadowColor = "rgba(0, 0, 0, 0.15)";
          context.shadowBlur = 4;
          context.shadowOffsetY = 2;

          roundRect(doraX, doraY, doraWidth, doraHeight, 4);
          context.fillStyle = "#ffffff";
          context.fill();

          context.save();
          context.clip();
          if (doraImage) {
            context.drawImage(doraImage, doraX, doraY, doraWidth, doraHeight);
          }
          context.restore();

          context.strokeStyle = "#bcbcbc";
          context.lineWidth = 0.5;
          context.stroke();

          context.restore();
        }

        let totalHandWidth = handTiles.length * tileWidth;
        if (nakiTileSets.length > 0) {
          totalHandWidth += 20;
          for (const tiles of nakiTileSets) {
            totalHandWidth += tiles.length * tileWidth + 10;
          }
        }

        let currentX = (canvas.width - totalHandWidth) / 2;
        const handY = 100;

        for (const code of handTiles) {
          await drawRoundedTile(
            code,
            currentX,
            handY,
            tileWidth,
            tileHeight,
            radius,
          );
          currentX += tileWidth;
        }

        if (nakiTileSets.length > 0) {
          currentX += 20;
          for (const tiles of nakiTileSets) {
            for (const code of tiles) {
              await drawRoundedTile(
                code,
                currentX,
                handY,
                tileWidth,
                tileHeight,
                radius,
              );
              currentX += tileWidth;
            }
            currentX += 10;
          }
        }
      }

      async function drawRoundedTile(code, x, y, width, height, cornerRadius) {
        const image = await loadImage(code);
        context.save();
        context.shadowColor = "rgba(0, 0, 0, 0.4)";
        context.shadowBlur = 10;
        context.shadowOffsetX = 2;
        context.shadowOffsetY = 5;

        roundRect(x, y, width, height, cornerRadius);
        context.fillStyle = "#ffffff";
        context.fill();

        context.clip();
        context.shadowColor = "transparent";

        if (image) {
          context.drawImage(image, x, y, width, height);
          const gradient = context.createLinearGradient(x, y, x, y + height);
          gradient.addColorStop(0.8, "transparent");
          gradient.addColorStop(1, "rgba(0, 0, 0, 0.1)");
          context.fillStyle = gradient;
          context.fillRect(x, y, width, height);
        } else {
          context.fillStyle = "#eeeeee";
          context.fillRect(x, y, width, height);
          context.fillStyle = "#000000";
          context.font = "14px sans-serif";
          context.textAlign = "center";
          context.textBaseline = "middle";
          context.fillText(code, x + width / 2, y + height / 2);
        }

        context.restore();
      }

      function downloadImage() {
        const link = document.createElement("a");
        const now = new Date();
        const fileName = `nanikiru_${now.getHours()}${now.getMinutes()}${now.getSeconds()}.png`;

        link.download = fileName;
        link.href = canvas.toDataURL("image/png");

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    </script>
  </body>
</html>
